<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ assembly name="$(SolutionDir)Libs\FxCopSdk.dll" #>
<#@ assembly name="$(SolutionDir)Libs\Stikeman.ServiceModel.Flow.dll" #>
<#@ assembly name="$(SolutionDir)Libs\Microsoft.Cci.dll" #>
<#@ import namespace="Microsoft.Cci" #>
<#+
  Dictionary<System.String, System.String> globalClasses = new Dictionary<System.String, System.String>();
  List<string> ignoredTypes = new List<string>()
	{
		"ObjectChangeTracker",
		"CollectionHistoryEntryType",
		"CollectionHistory",
		"CollectionHistoryXRef",
		"ObjectsAddedToCollectionProperties",
		"ObjectsRemovedFromCollectionProperties",
		"ObjectState",
		"OriginalValuesDictionary",
		"ExtendedPropertiesDictionary",
		"CollectionHistoryXRef",
		"System.Collections.Generic.List<Client>",
		"System.Collections.Generic.List<Matter>",
		"System.Byte[]"
	};

  void SaveOutput(string outputFileName)
  {
      string templateDirectory = Path.GetDirectoryName(Host.TemplateFile) + @"\Generated";
      string outputFilePath = Path.Combine(templateDirectory, outputFileName);
      File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString());
      this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
  }
  string GenerateProperty(Property property)
  {

		Type propertyType = property.Type.GetRuntimeType();
		string targetType = propertyType.ToString();
		if(targetType.Contains("System.Nullable`1"))
		{
			targetType = targetType.Replace("`1[", "<").Replace("]", ">");
		}
		else if(targetType.Contains("Stikeman.ServiceModel.Flow.Contracts."))
		{
			targetType =  targetType.Replace("Stikeman.ServiceModel.Flow.Contracts.", "");
			
		}
		else if(targetType.Contains("System.Collections.Generic.List`1["))
		{
			targetType = targetType.Replace("`1[", "<").Replace("]", ">");
		}
		
		return targetType;
  }

  void GenerateDomainModelObject(string library, string sourceType, string targetClass)
  {
	if(globalClasses.ContainsKey(sourceType)) return;
	globalClasses.Add(sourceType, targetClass);
	Dictionary<System.String, System.String> extended = new Dictionary<System.String, System.String>();
	System.IServiceProvider hostServiceProvider = (IServiceProvider)this.Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
	string path = System.IO.Path.GetDirectoryName(dte.Solution.FullName) + @"\Libs\" + library;
#>
// ---------------------------------------------------------------------------------------------------
//<auto-generated>
//	This code was generated by a tool:  SD.XXX.DomainModel -> Template.tt.
//  Generated date: '<#= DateTime.Now #>'
//	Any code changes can cause serious problems with model behaviour, and will be lost in next code generation. 
//	Please use 'partial' classes instead. 
//</auto-generated>
// ---------------------------------------------------------------------------------------------------
namespace SD.XXX.DomainModel
{
<#+
	AssemblyNode assembly = AssemblyNode.GetAssembly(path);
	Identifier namespaceId = Identifier.For("Stikeman.ServiceModel.Flow.Contracts");
	Identifier typeId = Identifier.For(sourceType);
    TypeNode typeInfo = assembly.GetType(namespaceId, typeId);
#>
	[SD.XXX.DomainModel.Metadata.GeneratedCode]
	public partial class  <#= targetClass #>
	{
<#+   
   foreach (Member member in typeInfo.Members)
   {
		if(member.IsPublic && member is Property)
		{
		Property property = member as Property;
		bool isReadonly  = !property.GetPropertyInfo().CanWrite || property.GetPropertyInfo().GetSetMethod() == null;
		string readonlyAttribute = isReadonly ? "[Metadata.Readonly]" : "";
		string propertyTypeFullText = property.Type.GetRuntimeType().ToString();
		string propertyType = GenerateProperty(property);
		if(propertyTypeFullText.Contains("LexisNexis.XXXModel.Entities") && !extended.ContainsKey(propertyType))
		{
			if(propertyType.Contains("<"))
			{
				System.Int32 from = propertyType.IndexOf('<')+1;
				System.Int32 to =  propertyType.IndexOf('>');
				string t = propertyType.Substring(from, to-from );
				if(!extended.ContainsKey(t))
					extended.Add(t, t);
			}
			else
			{
			if(!extended.ContainsKey(propertyType))
				extended.Add(propertyType, propertyType);
			}

		}
   #>
		<#= ignoredTypes.Contains(propertyType) ? "//":""#><#=readonlyAttribute#>
		<#= ignoredTypes.Contains(propertyType) ? "//":""#><#= String.Format("public {0} {1} {{ get; set; }}", propertyType, property.Name) #>
<#+}}#>
	}
}
<#+ 
	SaveOutput(targetClass + ".generated.cs");
	foreach (KeyValuePair<string, string> p in extended)
	{
		GenerateDomainModelObject("Stikeman.ServiceModel.Flow.dll", p.Key, p.Value);
	}
}
#>